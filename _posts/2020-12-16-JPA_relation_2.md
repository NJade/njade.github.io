---
title: JPA Relation 2
author: Njade
date: 2020-12-16 00:25:00 +0900
categories: [JPA]
tags: [JPA]
---

이 게시글은 인프런의 [김영한님의 강의](https://www.inflearn.com/course/ORM-JPA-Basic)를 보고 정리한 것입니다.
실전 예제의 팁 등을 제외한 코드는 첨부하지 않습니다. 강의를 봐주세요.

---

## 다양한 연관관계 맵핑
---
* 연관관계 맵핑시 고려사항 3가지
* 다대일 [N:1]
* 일대다 [1:N]
* 일대일 [1:1]
* 다대다 [N:N]

---

## 연관관계 맵핑시 고려사항 3가지
---
### 다중성
* 다대일: @ManyToOne
* 일대다: @OneToMany
* 일대일: @OneToOne
* 다대다: @ManyToMany > 실무에서 사용하지 말 것

### 단방향, 양방향
* 테이블: 외래 키 하나로 양쪽 조인이 가능한 방향이라는 개념이 없음
* 객체: 참조용 필드가 있는 쪽만 참조 가능, 한쪽만 참조하면 단방향, 양쪽 참조면 양방향

### 연관관계의 주인
* 테이블은 외래 키가 하나
* 객체는 참조가 2군데
* 두 객체 중 테이블의 외래 키를 관리할 곳을 정해야 함.
* 외래 키를 관리하는 참조가 있는 곳이 주인
* 주인이 아닌 곳은 조회만 가능
* 다대일, 일대다 등에서 앞에 나오는 것이 주인

---

## 다대일 [N:1]
---
* 다대일 단방향상황에서 다대일 양방향으로의 확장은 테이블에 영향을 주지 않고 코드상으로만 추가가 가능
* 외래키가 있는 쪽이 연관관계의 주인

---

## 일대다 [1:N]
---
* 1이 주인
* 일반적으로 권장하지 않음.
* 테이블에서 생각하면 N쪽에 무조건 외래키가 들어감.
* 이 경우 1쪽 객체가 바뀌면 자신의 테이블이 아닌 다른 테이블로 sql이 실행되어 쿼리가 한 번 더 나감.
* 객체와 테이블의 관계를 명확하게 파악하지 않으면 코드와 sql이 맵핑되지 않아 해석상의 어려움이 생길 수 있음.
* 객체지향적으로는 살짝 부적절하더라도 DB설계에 맞춰 다대일 관계로 설계로 바꾸는 것이 좋음.
* @JoinColumn을 꼭 사용하여야 하며 이를 사용하지 않으면 조인 테이블을 사용하게 됨. (테이블이 하나 더 생김.) 
* 일대다 양방향은 공식적으로 존재하지 않지만 사용은 가능하다.
```java
@ManyToOne
@JoinColumn(insertable = false, updatable = false)
```
* 위 두개의 어노테이션을 통해 읽기 전용 필드를 사용해서 양방향처럼 사용하는 방법이다.

---

## 일대일 [1:1]
---
* 일대일은 반대도 일대일
* 주 테이블이나 대상 테이블 중에 외래 키 선택이 가능
* 외래 키에 DB에 유니크 제약조건이 추가되어야 한다.
* 다대일과 유사함.
* 외래키가 있는 곳이 연관관계의 주인
* 반대편은 mappedBy 적용.
* 일대일이지만 대상 테이블에 외래키가 있는 단방향의 경우 JPA가 지원해주지 않음.
* 양방향인 경우에는 대상 테이블에 외래키가 있으면 가능하지만 사실 일대일 주 테이블의 양방향과 동일.

### 주 테이블에 외래키
* 개발상에서는 주 테이블에 외래키를 가지고 있는 경우 JPA 맵핑이 편리하고 추가 쿼리를 실행할 필요가 없어 이점이 있을 수 있다.
* 값이 없으면 외래키에 null이 들어가는 등의 단점이 있을 수 있다.

### 대상 테이블에 외래 키
* DB관점에서 일대다가 되는 경우 테이블 구조가 유지될 수 있다.
* 프록시 기능의 한계로 지연 로딩으로 설정하여도 어차피 쿼리해봐야 결과를 알 수 있기 때문에 항상 즉시 로딩된다.

---

## 다대다 [N:M]
---
* 실무에서는 사용하지 말 것.
* RDB에서 정규화된 테이블은 다대다가 표현이 안됨.
* 연결 테이블을 사용해서 일대다, 다대일 관계로 표현해야 함.
* 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계가 가능.
* @ManyToMany, @JoinTable로 지정이 가능하며 단방향, 양방향이 가능하다.
* 양방향은 동일하게 mappedBy를 사용해야함.
* 실무에서는 연결 테이블이 연결만 하고 끝나는 일이 없고 추가정보가 꼭 들어가기 때문에 사용하지 않는 것이 좋음.
* 연결 테이블용 엔티티를 만드는 것이 좋다.
* 연결 테이블도 PK는 의미없는 sequence를 사용하는 것이 유연해질 수 있다.

---

## 실전 예제
---
* JPA는 parent와 같은 형태의 셀프 맵핑도 가능함.
* 실무에서 중간 테이블은 단순하지 않으므로 @ManyToMany를 사용하지 말 것.
* @JoinColumn은 외래키를 맵핑할 때 사용
  * name: 매핑할 외래 키 이름
  * referencedColumnName: 외래 키가 참조하는 대상 테이블의 컬럼명
  * foreignKey(DDL): 외래키 제약조건을 직접 지정
  * 이외에는 @Column과 동일
* @ManyToOne
  * optional: 기본값 true
  * fetch: 기본값 EAGER
  * cascaed: 영속성 전이 기능
  * targetEntity: 연관된 엔티티의 타입 정보를 설정, 거의 사용하지 않음. 컬렉션 제네릭으로 타입 정보 추론.
  * 스펙상 mappedBy가 없음. > 무조건 주인이 되어야 함.
* @OneToMany
  * mappedBy: 주인 필드 선택
  * fetch: 기본값 LAZY
  * cascaed: 영속성 전이 기능
  * targetEntity: 연관된 엔티티의 타입 정보를 설정, 거의 사용하지 않음. 컬렉션 제네릭으로 타입 정보 추론.
  
---

# Reference
---
- [인프런](https://www.inflearn.com/course/ORM-JPA-Basic)
