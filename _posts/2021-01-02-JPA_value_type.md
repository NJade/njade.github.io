---
title: JPA value type
author: Njade
date: 2021-01-02 19:30:00 +0900
categories: [JPA]
tags: [JPA]
---

이 게시글은 인프런의 [김영한님의 강의](https://www.inflearn.com/course/ORM-JPA-Basic)를 보고 정리한 것입니다.
실전 예제의 팁 등을 제외한 코드는 첨부하지 않습니다. 강의를 봐주세요.

---

## 기본값 타입
---
### 엔티티 타입
* @Entity 로 정의하는 객체
* 데이터가 변해도 식별자로 지속해서 추적 가능

### 값 타입
* int, String 등 단순히 값으로 사용하는 자바 기본 타입이나 객체
* 식별자가 없고 값만 있어 추적이 불가능

---

## 기본값 타입
---
* primitive 타입, wrapper 타입, String
* 생명주기를 엔티티에 의존
* 값 타입은 공유하면 안됨. > 회원 이름 변경 시 다른 회원의 이름도 변경되는 경우 등 사이드 이펙트를 일으키면 안됨.
* 자바의 기본값 타입은 값을 복사(primitive type)하거나 변경이 불가능(Integer, String)하게 하여 공유되지 않음.

---

## 임베디드 타입
---
* 주로 기본 값 타입을 모아서 만든 복합 값 타입, position 등
* 재사용, 높은 응집도, 의미 있는 메서드를 생성가능하며 엔티티의 생명주기에 의존시킬 수 있다.
* DB는 값을 저장만 하면 되기 떄문에 변화가 없으나 객체는 메서드가 포함되기 때문에 이러한 타입을 생성하면 객체지향적 설계성이 좋아진다.
* @Embeddable로 값 타입을 정의하는 곳에 표시하고 @Embedded를 값 타입을 사용하는 곳에 표시한다. 
* 기본 생성자는 반드시 있어야 한다.
* 객체와 테이블을 세밀하게 맵핑하는 것이 가능해진다.
* 잘 설계한 ORM은 테이블 수보다 클래스 수가 더 많다.
* 임베디드 타입은 임베디드 타입과 엔티티 타입도 가질 수 있다.
* @AttributeOverrides, @AttributeOverride를 통해 한 엔티티에서 같은 값 타입을 사용할 수 있다.
* 임베디드 타입 값을 null로 처리하면 db에는 모두 null로 들어간다.

---

## 값 타입과 불변 객체
---
* 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 사이드 이펙트가 발생할 수 있다.
* 값을 공유하고 싶다면 엔티티로 만들어 쓰는 것이 적절하다.
* 객체의 공유 참조는 피할 수 없다.
* 값 타입은 값을 변경할 수 없는 불변 객체로 만들어야 한다.

---

## 값 타입의 비교
---
* 임베디드 타입의 경우 ==을 하면 참조값 비교로 false가 나오게 된다.
* 동일성 비교(참조 값을 비교)와 동등성 비교(인스턴스의 값을 비교)를 구분하여야 한다.
* 동등성 비교를 위해 equals와 hashcode를 같이 구현해주는 것이 적절하다.

---

## 값 타입 컬렉션
---
* 전통적인 rdbms에서 컬렉션은 1대다 관계로 별도의 테이브로 들어가게 된다.
* @ElementCollection과 @CollectionTable로 맵핑할 수 있다.
* @CollectionTable의 joinColumns를 사용하여 맵핑한다.
* 값 타입 컬렉션도 값 타입이므로 라이프 사이클이 엔티티에 의존한다.
* 기본 fetch 전략이 lazy로 잡혀 있다.
* 값 타입은 식별자가 없어 변경시 추적이 어렵다.
* 값 타입 컬렉션에 변경 사항이 발생하면 주인 엔티티와 연관된 모든 데이터를 삭제하고 값 타입 컬렉션에 있는 현재 데이터를 모도 다시 저장한다.
* OrderColumn을 쓰면 일부 방지가 되지만 다른 문제가 발생될 수 있다.
* 값 타입 컬렉션을 맵핑하는 테이블은 모든 컬럼을 묶어서 기본 키로 구성하면 위 문제를 해결할 수 있지만 null이나 중복 저장이 되지 않는다.
* 실무에서는 상황에 따라 값 타입 컬렉션이 아닌 엔티티 레벨로 올려 일대다 관계를 고려해야 한다.
* 이를 위해 일대다 관계를 위한 엔티티를 만들고 이 클래스에서 값 타입을 사용한다.
* 주인 객체에 일대다 엔티티를 맵핑하고 cascade와 orphanRemoval을 설정해준다.
* 매우 기본적인 경우가 아니라면 엔티티레벨로 쓰는 것이 좋다.

---

## 실전 예제
---
* equals나 hashcode 구현 시 프록시를 고려하여 getter를 사용하는 것이 좋다.
* 임베디드 타입으로 만든다면 공통의 룰과 공통의 비지니스 로직을 응집시킬 수 있다.

# Reference
---
- [인프런](https://www.inflearn.com/course/ORM-JPA-Basic)
